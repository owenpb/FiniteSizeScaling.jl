var documenterSearchIndex = {"docs":
[{"location":"demo_2/#Demo-2:-Two-parameter-scaling","page":"Demo 2: Two-parameter scaling","title":"Demo 2: Two-parameter scaling","text":"","category":"section"},{"location":"demo_2/","page":"Demo 2: Two-parameter scaling","title":"Demo 2: Two-parameter scaling","text":"(Image: Contour plot 1)","category":"page"},{"location":"demo_2/","page":"Demo 2: Two-parameter scaling","title":"Demo 2: Two-parameter scaling","text":"(Image: Contour plot 2)","category":"page"},{"location":"example_page/#Example:-Holstein-model","page":"Example: Holstein model","title":"Example: Holstein model","text":"","category":"section"},{"location":"example_page/","page":"Example: Holstein model","title":"Example: Holstein model","text":"The Holstein model is a simple tight-binding description of the electron-phonon interaction. On the square lattice, it exhibits a phase transition to charge density wave (CDW) order as the temperature is lowered, with the transition belonging to the 2D Ising universality class.  The measurement used to detect CDW order is the charge structure factor, which is the Fourier transform of the density-density correlation function:","category":"page"},{"location":"example_page/","page":"Example: Holstein model","title":"Example: Holstein model","text":"S(mathbfq) = frac1N sum_mathbfi mathbfj e^i mathbfq cdot (mathbfi - mathbfj) langle n_mathbfi n_mathbfj rangle","category":"page"},{"location":"example_page/","page":"Example: Holstein model","title":"Example: Holstein model","text":"where mathbfi and  mathbfj denote sites of the lattice, and n_mathbfi is the electron density at site mathbfi. When the CDW forms on the square lattice, electrons pair up and form a periodic \"checkerboard\" pattern consisting of alternating empty and doubly occupied sites. This is signaled by a peak in S(q) at the CDW ordering wavevector, which in this case is (pi pi). We therefore define the order parameter S_cdw = S(pi pi) which should grow rapidly below a critical temperature T_c. In particular, when long-range CDW order emerges, the order parameter S_cdw becomes sensitive to the finite size of the system, and thus below T_c should grow in proportion to the number of lattice sites N=L^2.","category":"page"},{"location":"example_page/","page":"Example: Holstein model","title":"Example: Holstein model","text":"(Image: Raw data)","category":"page"},{"location":"example_page/","page":"Example: Holstein model","title":"Example: Holstein model","text":"Generally, near a phase transition, physical quantities (such as the order parameter S_cdw) should scale with the reduced temperature t=(T-T_c)T_c raised to the power of some critical exponent. The correlation length xi in turn scales with t to the power of some critical exponent. However, for a finite size system, the more relevant length scale becomes the linear dimension L of the lattice. In this case, S_cdw should scale as some power of L multiplied by a function of the ratio Lxi. This is the scaling hypothesis, and forms the basis of the finite size scaling approach.","category":"page"},{"location":"example_page/","page":"Example: Holstein model","title":"Example: Holstein model","text":"For the square lattice Holstein model, the CDW transition breaks a Z_2 symmetry and thus belongs to the 2D Ising universality class, which has known critical exponents eta = 14 and nu = 1. Approaching the phase transition, the order parameter should scale as S_cdw sim L^2 - eta f(t L^1nu). Therefore if we plot:","category":"page"},{"location":"example_page/","page":"Example: Holstein model","title":"Example: Holstein model","text":"S_cdw L^-74 quad vs quad (beta - beta_c)L","category":"page"},{"location":"example_page/","page":"Example: Holstein model","title":"Example: Holstein model","text":"for different lattice sizes, the data should collapse onto a universal curve, allowing one to determine an estimate of the critical temperature beta_c = 1T_c. Below we show the data collapse for the square lattice Holstein model setting beta_c = 6 and using the Ising critical exponents.","category":"page"},{"location":"example_page/","page":"Example: Holstein model","title":"Example: Holstein model","text":"(Image: Scaled data)","category":"page"},{"location":"example_page/","page":"Example: Holstein model","title":"Example: Holstein model","text":"This package includes a number of methods for performing finite size scaling and for plotting results. In Demo 1, we show how to perform one-parameter scaling to find the optimal value of beta_c which produces the best data collapse for the square lattice Holstein model. In Demo 2, we show how two-parameter scaling can be performed by assuming the exponent 2-eta is unknown, and finding the optimal values of both beta_c and 2-eta which produce the best data collapse. ","category":"page"},{"location":"example_page/","page":"Example: Holstein model","title":"Example: Holstein model","text":"Note: The data used in these demos is provided in the examples folder of this package. This example data can be imported via:","category":"page"},{"location":"example_page/","page":"Example: Holstein model","title":"Example: Holstein model","text":"include(\"FiniteSizeScaling/examples/ExampleData.jl\")\nimport .ExampleData.example_data_with_error\nimport .ExampleData.example_data_no_error\nimport .ExampleData.example_fit_weights","category":"page"},{"location":"demo_1/#Demo-1:-One-parameter-scaling","page":"Demo 1: One-parameter scaling","title":"Demo 1: One-parameter scaling","text":"","category":"section"},{"location":"demo_1/","page":"Demo 1: One-parameter scaling","title":"Demo 1: One-parameter scaling","text":"In this demo we will show how to perform finite-size scaling where one free parameter is tuned to obtain the best possible data collapse. We will use the CDW transition in the square lattice Holstein model as an example, where the critical inverse temperature beta_c is to be optimized. ","category":"page"},{"location":"demo_1/","page":"Demo 1: One-parameter scaling","title":"Demo 1: One-parameter scaling","text":"Before we can perform finite-size scaling, we need to have data for several difference lattice sizes L. Suppose we have five lattice sizes L=4 6 8 10 12. For each lattice size, we will have an array of X values (i.e. values of the inverse temperature beta), an array of Y values (i.e. values of the order parameter S_cdw), and an array of E values which are the errors in each Y value. The data should be pre-arranged into arrays in the following way:","category":"page"},{"location":"demo_1/","page":"Demo 1: One-parameter scaling","title":"Demo 1: One-parameter scaling","text":"X_L4 = [1.973, 2.989, 3.978, 4.513, 4.754, 4.968, 5.182, 5.476, 5.743, 5.957, 6.225, 6.492, 7.000, 7.989, 8.979]\nY_L4 = [1.250, 1.806, 2.222, 3.056, 3.333, 3.750, 4.306, 4.583, 4.861, 5.278, 5.694, 5.972, 6.250, 6.806, 7.083]\nE_L4 = [0.114, 0.123, 0.132, 0.128, 0.135, 0.121, 0.130, 0.101, 0.108, 0.139, 0.133, 0.138, 0.128, 0.199, 0.137]\n\nX_L6 = [2.000, 2.989, 4.005, 4.513, 4.754, 4.995, 5.262, 5.476, 5.743, 6.011, 6.492, 7.000, 7.455, 7.989, 9.005, 9.995, 11.010, 12.000]\nY_L6 = [1.245, 1.667, 2.778, 4.444, 5.694, 6.667, 8.056, 9.306, 10.139, 10.972, 12.222, 13.333, 13.750, 14.167, 14.444, 14.583, 14.722, 14.722]\nE_L6 = [0.164, 0.153, 0.152, 0.148, 0.165, 0.151, 0.150, 0.161, 0.138, 0.169, 0.153, 0.148, 0.138, 0.149, 0.167, 0.155, 0.147, 0.160]\n\nX_L8 = [4.487, 4.727, 4.968, 5.235, 5.503, 5.743, 6.011, 6.225, 6.492, 6.733, 6.973, 7.267, 7.481, 7.775, 8.043, 8.524, 8.979, 10.021, 10.983, 12.000]\nY_L8 = [4.861, 5.694, 7.639, 10.278, 13.472, 15.417, 17.917, 19.583, 20.694, 21.528, 22.083, 22.361, 22.778, 23.194, 23.612, 23.889, 24.028, 24.583, 24.722, 24.722]\nE_L8 = [0.252, 0.289, 0.243, 0.324, 0.489, 0.524, 0.578, 0.609, 0.575, 0.589, 0.625, 0.621, 0.650, 0.623, 0.621, 0.602, 0.658, 0.665, 0.667, 0.689]\n\nX_L10 = [4.489, 4.757, 5.000, 5.244, 5.487, 5.755, 5.971, 6.293, 6.509, 6.750, 7.018, 7.259, 7.500, 7.768, 8.035, 10.041, 12.020]\nY_L10 = [4.583, 6.111, 9.306, 15.556, 19.861, 21.806, 25.833, 27.639, 31.111, 32.361, 33.333, 33.750, 34.722, 35.972, 35.694, 37.222, 37.500]\nE_L10 = [0.254, 0.289, 0.501, 1.189, 1.184, 0.790, 0.804, 1.045, 0.600, 0.584, 0.598, 0.655, 0.680, 0.640, 0.601, 0.575, 0.478]\n\nX_L12 = [4.493, 4.734, 4.981, 5.280, 5.528, 5.637, 5.777, 6.023, 6.268, 6.539, 6.809, 7.024, 7.292]\nY_L12 = [5.432, 6.964, 11.838, 16.713, 23.120, 25.627, 31.058, 36.072, 40.669, 43.454, 45.822, 47.075, 48.050]\nE_L12 = [0.321, 0.398, 0.401, 0.556, 0.531, 0.598, 0.601, 0.592, 0.625, 0.630, 0.587, 0.658, 0.688]","category":"page"},{"location":"demo_1/","page":"Demo 1: One-parameter scaling","title":"Demo 1: One-parameter scaling","text":"The next step is to create a single array of data, where each element is an array of X Y E L data for a given lattice size. The length of this new array will equal the number of different lattice sizes being used:","category":"page"},{"location":"demo_1/","page":"Demo 1: One-parameter scaling","title":"Demo 1: One-parameter scaling","text":"data_with_error = [[X_L4, Y_L4, E_L4, 4], [X_L6, Y_L6, E_L6, 6], [X_L8, Y_L8, E_L8, 8], [X_L10, Y_L10, E_L10, 10], [X_L12, Y_L12, E_L12, 12]]","category":"page"},{"location":"demo_1/","page":"Demo 1: One-parameter scaling","title":"Demo 1: One-parameter scaling","text":"If your Y data does not have error bars, you can also omit the arrays of error values, for example:","category":"page"},{"location":"demo_1/","page":"Demo 1: One-parameter scaling","title":"Demo 1: One-parameter scaling","text":"data_no_error = [[X_L4, Y_L4, 4], [X_L6, Y_L6, 6], [X_L8, Y_L8, 8], [X_L10, Y_L10, 10], [X_L12, Y_L12, 12]]","category":"page"},{"location":"demo_1/","page":"Demo 1: One-parameter scaling","title":"Demo 1: One-parameter scaling","text":"At this point, you can call the function plot_data to display the raw unscaled data:","category":"page"},{"location":"demo_1/","page":"Demo 1: One-parameter scaling","title":"Demo 1: One-parameter scaling","text":"plot_data(data_with_error)","category":"page"},{"location":"demo_1/","page":"Demo 1: One-parameter scaling","title":"Demo 1: One-parameter scaling","text":"(Image: Raw data)","category":"page"},{"location":"demo_1/","page":"Demo 1: One-parameter scaling","title":"Demo 1: One-parameter scaling","text":"As discussed in the Example page, we aim to rescale the data along new axes X_s = (beta - beta_c) L and Y_s = S_cdw L^-74. We will take beta_c to be the one free parameter we will tune to obtain the optimal data collapse, and denote it v_1, i.e. our scaled axes will be X_s = (X - v_1) L and Y_s = Y L^-74. For one-parameter scaling, the user now must define two functions which define the scaled X and Y axes:","category":"page"},{"location":"demo_1/","page":"Demo 1: One-parameter scaling","title":"Demo 1: One-parameter scaling","text":"x_scaled(X, L, v1) = (X .- v1) * L","category":"page"},{"location":"demo_1/","page":"Demo 1: One-parameter scaling","title":"Demo 1: One-parameter scaling","text":"y_scaled(Y, L, v1) = Y * (L^(-7/4))","category":"page"},{"location":"demo_1/","page":"Demo 1: One-parameter scaling","title":"Demo 1: One-parameter scaling","text":"The function defining the X_s axis should take X, L, and v_1 as arguments, while the function defining the scaled Y_s axis should take Y, L, and v_1 as arguments. Note that since X and Y are arrays, elementwise operators such as - may be necessary.","category":"page"},{"location":"demo_1/","page":"Demo 1: One-parameter scaling","title":"Demo 1: One-parameter scaling","text":"To determine the best of v_1, a search is performed between an initial value v_1i and a final value v_1f. For each candidate value of v_1, the data is scaled according to the user-defined formulae above, and a polynomial curve of order p is fit to the data, using the method of least squares to minimize the sum of squared residuals between the scaled data and the polynomial curve. The value of v_1 which yields the smallest sum of squared residuals is identified as the optimal value. ","category":"page"},{"location":"demo_1/","page":"Demo 1: One-parameter scaling","title":"Demo 1: One-parameter scaling","text":"When performing the fit, one has the option to multiply each squared residual by a weight W. For example, to perform weighted-least squares, these weights are typically inverse variances. This means that data points with larger error bars will be deemed less important for the fit, and vice-versa. To use weights when performing the fit, define an array as follows:","category":"page"},{"location":"demo_1/","page":"Demo 1: One-parameter scaling","title":"Demo 1: One-parameter scaling","text":"fit_weights = [1 ./ (E_L4.^2), 1 ./ (E_L6.^2), 1 ./ (E_L8.^2), 1 ./ (E_L10.^2), 1 ./ (E_L12.^2)]","category":"page"},{"location":"demo_1/","page":"Demo 1: One-parameter scaling","title":"Demo 1: One-parameter scaling","text":"where each element is an array of W values for a given lattice size. Here inverse variances have been chosen to perform a typical weighted least-squares. Note that the length of this array will equal the number of different lattice sizes being used. Using weights is completely optional and can be omitted if desired when calling the function fss_one_var.","category":"page"},{"location":"demo_1/","page":"Demo 1: One-parameter scaling","title":"Demo 1: One-parameter scaling","text":"The next step is to call the function fss_one_var to perform the finite-size scaling. ","category":"page"},{"location":"demo_1/","page":"Demo 1: One-parameter scaling","title":"Demo 1: One-parameter scaling","text":"scaled_data, residuals, min_res, best_v1 = fss_one_var(data=data_with_error, xs=x_scaled, ys=y_scaled, v1i=5.0, v1f=7.0, n1=100, p=4, weights=fit_weights)","category":"page"},{"location":"demo_1/","page":"Demo 1: One-parameter scaling","title":"Demo 1: One-parameter scaling","text":"where data is the single array of data defined previously, xs and ys are the functions previously defined for the scaled axes, v1i and v1f are the start and end points of the parameter search, n1 is the number of values of v_1 in this range to check. The integer degree p of the polynomial must also be specified, typically 4 leq p leq 8 is sufficient.  ","category":"page"},{"location":"demo_1/","page":"Demo 1: One-parameter scaling","title":"Demo 1: One-parameter scaling","text":"The function fss_one_var returns four variables: an array scaled_data where each element is an array of X_s Y_s E_s L data for a given lattice size; an array residuals of length n1 which stores the sum of squared residuals for each value of v_1 checked; a scalar min_res which is the minimum value of the array residuals; and a scalar best_v1 which is the value of v_1 which gave the smallest overall residual. By default it will also print out the values of best_v1 and min_res:","category":"page"},{"location":"demo_1/","page":"Demo 1: One-parameter scaling","title":"Demo 1: One-parameter scaling","text":"Optimal v1 value: 6.1313131313131315 \nSmallest residual: 0.12847365603386035 ","category":"page"},{"location":"demo_1/","page":"Demo 1: One-parameter scaling","title":"Demo 1: One-parameter scaling","text":"note: Note: When $Y_s$ explicitly depends on $v_1$ set norm_y=true\nWhen the scaled vertical axis Y_s has an explicit dependence on the tuned parameter v_1 (and/or v_2 for two-parameter scaling), the magnitude of Y_s values can vary drastically during the parameter sweep. In determining the relative quality of fit of a polynomial to the scaled data, the absolute magnitude of the sum of squared residuals therefore may not be an appropriate choice. In this case, each individual fit residual should be divided by the magnitude Y_s of the corresponding data point. Then, the sum of the squares of these \"normalized\" residuals will provide a true measure of the relative quality of the polynomial fitting.To do this, both fss_one_var and fss_two_var takes an optional boolean argument norm_y. Set norm_y=true to normalize the fit residuals. ","category":"page"},{"location":"demo_1/","page":"Demo 1: One-parameter scaling","title":"Demo 1: One-parameter scaling","text":"At this point, you can again call the function plot_data, passing in the scaled_data returned by the fss_one_var function. This will produce a plot of the optimal data collapse, i.e. the scaled data with v_1 set to best_v1:","category":"page"},{"location":"demo_1/","page":"Demo 1: One-parameter scaling","title":"Demo 1: One-parameter scaling","text":"plot_data(scaled_data)","category":"page"},{"location":"demo_1/","page":"Demo 1: One-parameter scaling","title":"Demo 1: One-parameter scaling","text":"(Image: Scaled data)","category":"page"},{"location":"demo_1/","page":"Demo 1: One-parameter scaling","title":"Demo 1: One-parameter scaling","text":"After one-parameter finite-size scaling has been performed, we can plot the dependence of the sum of squared residuals on v_1. To do this use the plot_residuals function, and pass in the array of residuals returned by fss_one_var, along with the exact values of v1i, v1f, and n1 which were used:","category":"page"},{"location":"demo_1/","page":"Demo 1: One-parameter scaling","title":"Demo 1: One-parameter scaling","text":"plot_residuals(residuals, v1i=5.0, v1f=7.0, n1=100)","category":"page"},{"location":"demo_1/","page":"Demo 1: One-parameter scaling","title":"Demo 1: One-parameter scaling","text":"(Image: Residuals plot)","category":"page"},{"location":"demo_1/","page":"Demo 1: One-parameter scaling","title":"Demo 1: One-parameter scaling","text":"tip: Tip\nWhen using plotting functions such as plot_data or plot_residuals, plot attributes such as axes labels, font sizes, marker sizes, colors, and figure dimensions can be easily passed as optional arguments. See the docstrings of each plotting function or the Methods page for full details. ","category":"page"},{"location":"methods/","page":"Methods","title":"Methods","text":"CurrentModule = FiniteSizeScaling","category":"page"},{"location":"methods/#Methods","page":"Methods","title":"Methods","text":"","category":"section"},{"location":"methods/","page":"Methods","title":"Methods","text":"A list of all available methods in the FiniteSizeScaling module.","category":"page"},{"location":"methods/","page":"Methods","title":"Methods","text":"Modules = [FiniteSizeScaling]","category":"page"},{"location":"methods/","page":"Methods","title":"Methods","text":"Modules = [FiniteSizeScaling]","category":"page"},{"location":"methods/#FiniteSizeScaling.fss_one_var-Tuple{}","page":"Methods","title":"FiniteSizeScaling.fss_one_var","text":"fss_one_var(; data::AbstractVector, xs::Function, ys::Function, v1i::Real, v1f::Real, n1::Int, p::Int, weights::AbstractArray=nothing, norm_y::Bool=false, verbose::Bool=true)\n\nPerforms finite size scaling with one optimized parameter v1.\n\nArguments:\n\ndata::AbstractVector: An array of input data, where each element is an array of [X, Y, E, L] data for a given lattice size (error E optional). The length of data should equal the number of lattice sizes.\nxs::Function: A function of the variables (X, L, v1) which specifies how the data is to be scaled horizontally.\nys::Function: A function of the variables (Y, L, v1) which specifies how the data is to be scaled vertically.\nv1i::Real: Initial value of v1 used in the search for optimal fit.\nv1f::Real: Final value of v1 used in the search for optimal fit.\nn1::Int: Number of v1 values used in the search for optimal fit.\np::Int: Degree of polynomial used in the fitting.\nweights::AbstractVector: An optional array of weight data, where each element is an array of [W] data for a given lattice size. The length of weights should equal the number of lattice sizes. These weights multiply the squared residuals when performing the fit, and are typically inverse variances (1./ (E.^2)) for weighted least-squares.\nnorm_y::Bool: If true, each residual calculated (when evaluating the fit) is divided by the y-value of the data point. Recommended if scaling v1 changes the y-axis scale.\nverbose:Bool: If true, prints the optimal v1 value and the magnitude of the smallest residual.\n\nReturns:\n\nscaled_data_array: An array of scaled data, where each element is an array of [Xs, Ys, E, L] data for a given lattice size (error E optional). The length of scaled_data_array should equal the number of lattice sizes.\nresiduals: An array of length n1 with values of the sum of squared residuals for each value of v1 used in the search.\nmin_res: The smallest value of the sum of squared residuals found in the search.\nbest_v1: The optimal value of v1 found in the search.\n\n\n\n\n\n","category":"method"},{"location":"methods/#FiniteSizeScaling.fss_two_var-Tuple{}","page":"Methods","title":"FiniteSizeScaling.fss_two_var","text":"fss_two_var(; data::AbstractVector, xs::Function, ys::Function, v1i::Real, v1f::Real, n1::Int, v2i::Real, v2f::Real, n2::Int, p::Int, weights::AbstractArray=nothing, norm_y::Bool=false, verbose::Bool=true)\n\nPerforms finite size scaling with two optimized parameters v1 and v2.\n\nArguments:\n\ndata::AbstractVector: An array of input data, where each element is an array of [X, Y, E, L] data for a given lattice size (error E optional). The length of data should equal the number of lattice sizes.\nxs::Function: A function of the variables (X, L, v1, v2) which specifies how the data is to be scaled horizontally.\nys::Function: A function of the variables (Y, L, v1, v2) which specifies how the data is to be scaled vertically.\nv1i::Real: Initial value of v1 used in the search for optimal fit.\nv1f::Real: Final value of v1 used in the search for optimal fit.\nn1::Int: Number of v1 values used in the search for optimal fit.\nv2i::Real: Initial value of v2 used in the search for optimal fit.\nv2f::Real: Final value of v2 used in the search for optimal fit.\nn2::Int: Number of v2 values used in the search for optimal fit.\np::Int: Degree of polynomial used in the fitting.\nweights::AbstractArray: An optional array of weight data, where each element is an array of [W] data for a given lattice size. The length of weights should equal the number of lattice sizes. These weights multiply the squared residuals when performing the fit, and are typically inverse variances (1./ (E.^2)) for weighted least-squares.\nnorm_y::Bool: If true, each residual calculated (when evaluating the fit) is divided by the y-value of the data point. Recommended if scaling v1 changes the y-axis scale.\nverbose::Bool: If true, prints the optimal v1 value and the magnitude of the smallest residual.\n\nReturns:\n\nscaled_data_array: An array of scaled data, where each element is an array of [Xs, Ys, E, L] data for a given lattice size (error E optional). The length of scaled_data_array should equal the number of lattice sizes.\nresiduals: An array of dimensions (n2, n1) with values of the sum of squared residuals for each pair of (v2, v1) values used in the search.\nmin_res: The smallest value of the sum of squared residuals found in the search.\nbest_v1: The optimal value of v1 found in the search.\nbest_v2: The optimal value of v2 found in the search.\n\n\n\n\n\n","category":"method"},{"location":"methods/#FiniteSizeScaling.plot_contour-Tuple{AbstractArray}","page":"Methods","title":"FiniteSizeScaling.plot_contour","text":"plot_contour(residuals::AbstractArray; v1i::Real, v1f::Real, n1::Int, v2i::Real, v2f::Real, n2::Int, levels, fill::Bool=true, logspace::Bool=true, xlabel::AbstractString=L\"$v_1$\", ylabel::AbstractString=L\"$v_2$\", xguidefontsize::Real=16, yguidefontsize::Real=16, xtickfontsize::Real=10, ytickfontsize::Real=10, color::Symbol=:algae, markershape::Symbol=:star4, markersize::Real=6, markercolor::Symbol=:yellow, size::Tuple=(800,500))\n\nProduces a contour plot showing the sum of squared residuals as a function of v1 (x-axis) and v2 (y-axis) after two-parameter scaling has been performed using fss_two_var. The optimal values of v1 and v2 are indicated on the plot.    \n\nArguments:\n\nresiduals::AbstractArray: Two-dimensional array of residual values obtained after two-parameter fit has been performed. This is the array residuals returned by the function fss_two_var.\nv1i::Real: Initial value of v1 used in the search for optimal fit. Should be the same value used when calling the function fss_two_var.\nv1f::Real: Final value of v1 used in the search for optimal fit. Should be the same value used when calling the function fss_two_var.\nn1::Int: Number of v1 values used in the search for optimal fit. Should be the same value used when calling the function fss_two_var.\nlevels: Can be an integer or an array. If an integer, this specfies the number of contour lines drawn. If an array, contour lines are drawn at the exact levels specified in the array.\nfill::Bool: If true, fills in the contour plot with solid color.\nlogspace::Bool If true, contour lines are spaced logarithmically. Recommended if a higher density of contour lines near the minima is desired.\nxlabel::AbstractString: Label for the horizontal axis. Can be a LaTexString e.g. L\"x\".\nylabel::AbstractString: Label for the vertical axis. Can be a LaTexString e.g. L\"y\". \nxguidefontsize::Real: Font size for x-axis label.\nyguidefontsize::Real: Font size for y-axis label.\nxtickfontsize::Real: Font size for x-axis ticks.\nytickfontsize::Real: Font size for y-axis ticks.\ncolor::Symbol: Color scheme used in contour plot. Symbol can be any color scheme supported by Plots.jl.\nmarkershape::Symbol: Shape of marker used to pinpoint the optimal parameter values. Can be any markershape Symbol defined in Plots.jl.\nmarkersize::Real: Size of marker used to pinpoint the optimal parameter values. \nmarkercolor::Symbol: Color of marker used to pinpoint the optimal parameter values. Can be any markercolor Symbol defined in Plots.jl.\nsize::Tuple: Size of contour plot drawn.\n\n\n\n\n\n","category":"method"},{"location":"methods/#FiniteSizeScaling.plot_data-Tuple{AbstractArray}","page":"Methods","title":"FiniteSizeScaling.plot_data","text":"plot_data(data::AbstractArray; xlabel::AbstractString=L\"$x$\", ylabel::AbstractString=L\"$y$\", xguidefontsize::Real=16, yguidefontsize::Real=16, xtickfontsize::Real=10, ytickfontsize::Real=10, legend::Symbol=:topleft, legendfontsize::Real=10, markershape::Symbol=:circle, markersize::Real=4, palette::Symbol=:tab10, size::Tuple=(600,400))\n\nPlots the data (either the unscaled data, or the optimal collapse of scaled data) for different lattice sizes. \n\nArguments:\n\ndata::AbstractArray: An array of input data, where each element is an array of [X, Y, E, L] data for a given lattice size (error E optional). The length of data should equal the number of lattice sizes. This could be the scaled_data_array returned by fss_one_var or fss_two_var, giving a plot of the best data collapse.\nxlabel::AbstractString: Label for the horizontal axis. Can be a LaTexString e.g. L\"x\".\nylabel::AbstractString: Label for the vertical axis. Can be a LaTexString e.g. L\"y\". \nxguidefontsize::Real: Font size for x-axis label.\nyguidefontsize::Real: Font size for y-axis label.\nxtickfontsize::Real: Font size for x-axis ticks.\nytickfontsize::Real: Font size for y-axis ticks.\nlegend::Symbol: Position of legend. Can be any legend Symbol defined in Plots.jl.\nlegendfontsize::Real: Font size used in legend.\nmarkershape::Symbol: Shape of markers used in scatter plot. Can be any markershape Symbol defined in Plots.jl.\nmarkersize::Real: Size of markers used in scatter plot.\npalette::Symbol: Color scheme used in scatter plot. Symbol can be any color scheme supported by Plots.jl.\nsize::Tuple: Dimensions of scatter plot drawn.\n\n\n\n\n\n","category":"method"},{"location":"methods/#FiniteSizeScaling.plot_residuals-Tuple{AbstractVector}","page":"Methods","title":"FiniteSizeScaling.plot_residuals","text":"plot_residuals(data::AbstractArray; xlabel::AbstractString=L\"$x$\", ylabel::AbstractString=L\"$y$\", xguidefontsize::Real=16, yguidefontsize::Real=16, xtickfontsize::Real=10, ytickfontsize::Real=10, legend::Symbol=:topleft, legendfontsize::Real=10, markershape::Symbol=:circle, markersize::Real=4, palette::Symbol=:tab10, size::Tuple=(600,400))\n\nPlots the sum of squared residuals (calculated with fss_one_var) as a function of v1, after one-parameter scaling has been performed. \n\nArguments:\n\nresiduals::AbstractVector: A vector containing values of the sum of squared residuals for each v1 value used in the optimization search. This is the vector residuals returned by the fss_one_var function.\nv1i::Real: Initial value of v1 used in the search for optimal fit. Should be the same value used when calling the function fss_one_var.\nv1f::Real: Final value of v1 used in the search for optimal fit. Should be the same value used when calling the function fss_one_var.\nn1::Int: Number of v1 values used in the search for optimal fit. Should be the same value used when calling the function fss_one_var.\nxlabel::AbstractString: Label for the horizontal axis. Can be a LaTexString e.g. L\"x\".\nylabel::AbstractString: Label for the vertical axis. Can be a LaTexString e.g. L\"y\". \nxguidefontsize::Real: Font size for x-axis label.\nyguidefontsize::Real: Font size for y-axis label.\nxtickfontsize::Real: Font size for x-axis ticks.\nytickfontsize::Real: Font size for y-axis ticks.\nmarkershape::Symbol: Shape of markers used in plot. Can be any markershape Symbol defined in Plots.jl.\nmarkercolor::Symbol: Color of markers used in plot. Can be markercolor Symbol defined in Plots.jl.\nmarkersize::Real: Size of markers used in plot.\nlinewidth::Real: Width of line used in plot.\nlinecolor::Symbol: Color of line used in plot. Symbol can be any linecolor Symbol defined in Plots.jl.\nsize::Tuple: Dimensions of scatter plot drawn.\n\n\n\n\n\n","category":"method"},{"location":"#FiniteSizeScaling.jl","page":"Home","title":"FiniteSizeScaling.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for FiniteSizeScaling.jl: a Julia package for finite-size scaling analysis. Uses finite-size scaling to find optimized values of critical exponents and phase transition temperatures given data for finite-size lattices.","category":"page"},{"location":"","page":"Home","title":"Home","text":"To get started, see the Examples page for a brief overview of the finite-size scaling method as applied to the Holstein model. Then see Demo 1 for a tutorial on using the package for optimizing one scaling parameter to obtain the best data collapse, and Demo 2 for an overview of how to optimize two scaling parameters.","category":"page"}]
}
