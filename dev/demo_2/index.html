<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Demo 2: Two-parameter scaling · FiniteSizeScaling.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://owenpb.github.io/FiniteSizeScaling.jl/demo_2/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">FiniteSizeScaling.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../methods/">Methods</a></li><li><a class="tocitem" href="../example_page/">Example: Holstein model</a></li><li><a class="tocitem" href="../demo_1/">Demo 1: One-parameter scaling</a></li><li class="is-active"><a class="tocitem" href>Demo 2: Two-parameter scaling</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Demo 2: Two-parameter scaling</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Demo 2: Two-parameter scaling</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/owenpb/FiniteSizeScaling.jl/blob/master/docs/src/demo_2.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Demo-2:-Two-parameter-scaling"><a class="docs-heading-anchor" href="#Demo-2:-Two-parameter-scaling">Demo 2: Two-parameter scaling</a><a id="Demo-2:-Two-parameter-scaling-1"></a><a class="docs-heading-anchor-permalink" href="#Demo-2:-Two-parameter-scaling" title="Permalink"></a></h1><p>In this demo we will show how to perform finite-size scaling where two free parameters are tuned to obtain the best possible data collapse. As in Demo 1, we will use the CDW transition in the square lattice Holstein model as an example, but this time both the critical inverse temperature <span>$\beta_c$</span> and the exponent <span>$2 - \eta \equiv \gamma/\nu$</span> are to be optimized, i.e. we do not assume the exponent is equal to its theoretical value of <span>$7/4$</span> for the Ising universality class.</p><p>Let us use the same data as in Demo 1, which as before has been loaded into an array of the form:</p><pre><code class="language- hljs">data_with_error = [[X_L4, Y_L4, E_L4, 4], [X_L6, Y_L6, E_L6, 6], [X_L8, Y_L8, E_L8, 8], [X_L10, Y_L10, E_L10, 10], [X_L12, Y_L12, E_L12, 12]]</code></pre><p>We now aim to rescale the data along new axes <span>$X_s = (\beta - \beta_c)L$</span> and <span>$Y_s = S_{cdw} L^{-(2-\eta)}$</span>. We will take <span>$\beta_c$</span> to the first free parameter we will tune to obtain the optimal data collapse, and denote it <span>$v_1$</span>, and we will take <span>$(2-\eta)$</span> to be the second free parameter, and denote it <span>$v_2$</span>. That is, our scaled axes will be <span>$X_s = (X - v_1)L$</span> and <span>$Y_s = Y L^{-v_2}$</span>. For two-parameter scaling, the user now must define two functions which define the scaled X and Y axes:</p><pre><code class="language- hljs">x_scaled(X, L, v1, v2) = (X .- v1) * L</code></pre><pre><code class="language- hljs">y_scaled(Y, L, v1, v2) = Y * (L^(-1 * v2))</code></pre><p>The functions defining the <span>$X_s$</span> axis should take <span>$X$</span>, <span>$L$</span>, <span>$v_1$</span>, and <span>$v_2$</span> as arguments, while the function defining the scaled <span>$Y_s$</span> axis should take <span>$Y$</span>, <span>$L$</span>, <span>$v_1$</span>, and <span>$v_2$</span> as arguments. Note that since <span>$X$</span> and <span>$Y$</span> are arrays, elementwise operators such as <span>$.-$</span> may be necessary.</p><p>To determine the best value of <span>$v_1$</span>, a search is performed between an initial value <span>$v_{1i}$</span> and a final value <span>$v_{1f}$</span>.  To determine the best value of <span>$v_2$</span>, a search is performed between an initial value <span>$v_{2i}$</span> and a final value <span>$v_{2f}$</span>. The finite-size scaling method works in the same way as for one-parameter scaling, except now the method finds the <em>pair</em> of <span>$v_1$</span> and <span>$v_2$</span> values which yield the minimal overall residual. As in Demo 1, we will use invariance variance weights to perform weighted least squares. </p><pre><code class="language- hljs">fit_weights = [1 ./ (E_L4.^2), 1 ./ (E_L6.^2), 1 ./ (E_L8.^2), 1 ./ (E_L10.^2), 1 ./ (E_L12.^2)]</code></pre><p>However, note that since our scaled <span>$Y_s$</span> axis depends exponentially on the tuned parameter <span>$v_2$</span>, it is important to &quot;normalize&quot; each calculated residual to obtain the best data collapse. To do this we will set <code>norm_y=true</code> when calling the two-parameter finite-size scaling function <code>fss_two_var</code>.</p><div class="admonition is-info"><header class="admonition-header">Note: When $Y_s$ explicitly depends on $v_1$ or $v_2$ set norm_y=true</header><div class="admonition-body"><p>When the scaled vertical axis <span>$Y_s$</span> has an explicit dependence on the tuned parameter <span>$v_1$</span> and/or <span>$v_2$</span>, the magnitude of <span>$Y_s$</span> values can vary drastically during the parameter sweep. In determining the <em>relative</em> quality of fit of a polynomial to the scaled data, the absolute magnitude of the sum of squared residuals therefore may not be an appropriate choice. </p><p>In this case, each individual fit residual should be divided by the magnitude <span>$Y_s$</span> of the corresponding data point. Then, the sum of the squares of these &quot;normalized&quot; residuals will provide a true measure of the relative quality of the polynomial fitting.</p><p>To do this, both <code>fss_one_var</code> and <code>fss_two_var</code> takes an optional boolean argument <code>norm_y</code>. Set <code>norm_y=true</code> to normalize the fit residuals. </p></div></div><p>The next step is to call the function <code>fss_two_var</code> to perform the finite-size scaling. </p><pre><code class="language- hljs">scaled_data, residuals, min_res, best_v1, best_v2 = fss_two_var(data=data_with_error, xs=x_scaled, ys=y_scaled, v1i=5.0, v1f=7.0, n1=100, v2i=1.0, v2f=2.0, n2=100, p=4, weights=fit_weights, norm_y=true)</code></pre><p>where <code>data</code> is the single array of data defined previously, and <code>xs</code> and <code>ys</code> are the functions previously defined for the scaled axes. Here <code>v1i</code> and <code>v1f</code> are the start and end points of the parameter search for <span>$v_1$</span> (in this example <span>$\beta_c$</span>), where <code>n1</code> is the number of values of <span>$v_1$</span> in this range to check. Similarly, <code>v2i</code> and <code>v1f</code> are the start and end points of the parameter search for <span>$v_2$</span> (in this example <span>$(2-\eta)$</span>), where <code>n2</code> is the number of values of <span>$v_2$</span> in this range to check.  The integer degree <span>$p$</span> of the polynomial must also be specified, typically <span>$4 \leq p \leq 8$</span> is sufficient.  </p><p>The function <code>fss_two_var</code> returns five variables: an array <code>scaled_data</code> where each element is an array of <span>$[X_s, Y_s, E_s, L]$</span> data for a given lattice size; a two-dimensional array <code>residuals</code> of dimension <code>(n2, n1)</code> which stores the sum of squared residuals for each pair of <span>$(v_2, v_1)$</span> values checked; a scalar <code>min_res</code> which is the minimum value of the array <code>residuals</code>; and scalars <code>best_v1</code> and <code>best_v2</code> which are the values of <span>$v_1$</span> and <span>$v_2$</span> which gave the smallest overall residual. By default it will also print out the values of <code>best_v1</code>, <code>best_v2</code>, and <code>min_res</code>:</p><pre><code class="language- hljs">Optimal v1 value: 6.090909090909091
Optimal v2 value: 1.6767676767676767
Smallest residual: 1.158515739950633 </code></pre><p>At this point, you can again call the function <code>plot_data</code>, passing in the <code>scaled_data</code> returned by the <code>fss_two_var</code> function. This will produce a plot of the optimal data collapse, i.e. the scaled data with <span>$v_1$</span> set to <code>best_v1</code> and <span>$v_2$</span> set to <code>best_v2</code>:</p><pre><code class="language- hljs">plot_data(scaled_data)</code></pre><p><img src="../scaled_data_2.png" alt="Scaled data"/></p><h3 id="Contour-plot-for-two-parameter-scaling"><a class="docs-heading-anchor" href="#Contour-plot-for-two-parameter-scaling">Contour plot for two-parameter scaling</a><a id="Contour-plot-for-two-parameter-scaling-1"></a><a class="docs-heading-anchor-permalink" href="#Contour-plot-for-two-parameter-scaling" title="Permalink"></a></h3><p>When performing two-parameter scaling, it is often useful to produce a contour plot showing how the quality of the data collapse varies in the <span>$(v1, v2)$</span> plane. To make this plot, use the function <code>plot_contour</code>, passing in the two-dimensional array <code>residuals</code> returned by <code>fss_two_var</code>. You will also need to pass in the same values of <code>v1i</code>, <code>v1f</code>, <code>n1</code>, <code>v2i</code>, <code>v2f</code>, and <code>n2</code> which were used in <code>fss_two_var</code>. You will also need to specify how many contour lines are drawn with the argument <code>levels</code>. <code>levels</code> can be either an integer or an array of values. If an array of values is specified, only contours corresponding to these values be drawn on the plot. If <code>levels</code> is an integer, this sets the total number of contour lines which will be drawn. The values represented by the contour lines can either be equally spaced or logarithmically spaced, which is set by the boolean argument <code>logspace</code>. Often logarthmic spacing is best in order to get a reasonable number of contour lines plotted near the minima, and <code>logspace=true</code> by default. A solid color fill between contour lines will be drawn if the boolean argument <code>fill</code>; by default <code>fill=true</code>. </p><pre><code class="language- hljs">plot_contour(residuals, v1i=5.0, v1f=7.0, n1=100, v2i=0.0, v2f=1.0, n2=100, levels=30, fill=true, logspace=true, xlabel=L&quot;\beta_c&quot;, ylabel=L&quot;2 - \eta&quot;) </code></pre><p>The <code>plot_contour</code> function produces a contour plot displaying the sum of squared residuals in the <span>$(v_1, v_2)$</span> plane, where a smaller value corresponds to a better quality data collapse. The minimum residual value is also indicated by a marker on the plot, showing the location of <code>(best_v1, best_v2)</code>:</p><p><img src="../contour_plot_1.png" alt="Contour plot 1"/></p><p>Note that various plot attributes such as the color scheme used, plot dimensions, marker size, marker color, marker shape, axes labels, and fontsizes can be customized when calling the function <code>plot_contour</code>. For example, the <code>color</code> argument can be set to any color scheme supported by <a href="https://github.com/JuliaPlots/Plots.jl">Plots.jl</a>. See the docstrings of <code>plot_contour</code> or the Methods page for full details. Below is a contour plot of the same residuals data as above, where several of these plot attributes have been modified.</p><pre><code class="language- hljs">plot_contour(residuals, v1i=5.0, v1f=7.0, n1=100, v2i=1.0, v2f=2.0, n2=100, levels=25, fill=true, logspace=true, xlabel=L&quot;\beta_c&quot;, ylabel=L&quot;2 - \eta&quot;, color=:terrain, markersize=7, markershape=:star5, markercolor=:white, size=(800,300)) </code></pre><p><img src="../contour_plot_2.png" alt="Contour plot 2"/></p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>To use LaTeX when specifying axes labels, you can use a LaTeXString e.g. <code>L&quot;\beta_c&quot;</code>. To use the <a href="https://github.com/stevengj/LaTeXStrings.jl">LaTeXStrings.jl</a> package, simply enter <code>using LaTeXStrings</code>.</p></div></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../demo_1/">« Demo 1: One-parameter scaling</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.15 on <span class="colophon-date" title="Friday 17 June 2022 05:29">Friday 17 June 2022</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
